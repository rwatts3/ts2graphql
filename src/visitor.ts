
// This file was autogenerated using ts-gen-transform
// https://github.com/samvv/ts-gen-transform

// Copyright 2017 Sam Vervaeck
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

import * as ts from "typescript"
import { Queryable } from "./types"

export class Visitor {

  protected _count: number

  visitToken<Kind extends ts.SyntaxKind>(node: Queryable<ts.Token<Kind>>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitIdentifier(node: Queryable<ts.Identifier>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitQualifiedName(node: Queryable<ts.QualifiedName>, parent: ts.Node | undefined) {
    this.visit(node.left, node);
    this.visit(node.right, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitComputedPropertyName(node: Queryable<ts.ComputedPropertyName>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitDecorator(node: Queryable<ts.Decorator>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTypeParameterDeclaration(node: Queryable<ts.TypeParameterDeclaration>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.constraint !== undefined) {
      this.visit(node.constraint, node);
    }
    if (node.default !== undefined) {
      this.visit(node.default, node);
    }
    if (node.expression !== undefined) {
      this.visit(node.expression, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitCallSignatureDeclaration(node: Queryable<ts.CallSignatureDeclaration>, parent: ts.Node | undefined) {
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    for (const el of node.parameters)
      this.visit(el, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
  }

  visitConstructSignatureDeclaration(node: Queryable<ts.ConstructSignatureDeclaration>, parent: ts.Node | undefined) {
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    for (const el of node.parameters)
      this.visit(el, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
  }

  visitVariableDeclaration(node: Queryable<ts.VariableDeclaration>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
    if (node.initializer !== undefined) {
      this.visit(node.initializer, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitVariableDeclarationList(node: Queryable<ts.VariableDeclarationList>, parent: ts.Node | undefined) {
    for (const el of node.declarations)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitParameterDeclaration(node: Queryable<ts.ParameterDeclaration>, parent: ts.Node | undefined) {
    if (node.dotDotDotToken !== undefined) {
      this.visit(node.dotDotDotToken, node);
    }
    this.visit(node.name, node);
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
    if (node.initializer !== undefined) {
      this.visit(node.initializer, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitBindingElement(node: Queryable<ts.BindingElement>, parent: ts.Node | undefined) {
    if (node.propertyName !== undefined) {
      this.visit(node.propertyName, node);
    }
    if (node.dotDotDotToken !== undefined) {
      this.visit(node.dotDotDotToken, node);
    }
    this.visit(node.name, node);
    if (node.initializer !== undefined) {
      this.visit(node.initializer, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitPropertySignature(node: Queryable<ts.PropertySignature>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
    if (node.initializer !== undefined) {
      this.visit(node.initializer, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitPropertyDeclaration(node: Queryable<ts.PropertyDeclaration>, parent: ts.Node | undefined) {
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
    this.visit(node.name, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
    if (node.initializer !== undefined) {
      this.visit(node.initializer, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitPropertyAssignment(node: Queryable<ts.PropertyAssignment>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
    this.visit(node.initializer, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitShorthandPropertyAssignment(node: Queryable<ts.ShorthandPropertyAssignment>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
    if (node.equalsToken !== undefined) {
      this.visit(node.equalsToken, node);
    }
    if (node.objectAssignmentInitializer !== undefined) {
      this.visit(node.objectAssignmentInitializer, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitSpreadAssignment(node: Queryable<ts.SpreadAssignment>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitObjectBindingPattern(node: Queryable<ts.ObjectBindingPattern>, parent: ts.Node | undefined) {
    for (const el of node.elements)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitArrayBindingPattern(node: Queryable<ts.ArrayBindingPattern>, parent: ts.Node | undefined) {
    for (const el of node.elements)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitFunctionDeclaration(node: Queryable<ts.FunctionDeclaration>, parent: ts.Node | undefined) {
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.body !== undefined) {
      this.visit(node.body, node);
    }
    if (node.asteriskToken !== undefined) {
      this.visit(node.asteriskToken, node);
    }
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    for (const el of node.parameters)
      this.visit(el, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitMethodSignature(node: Queryable<ts.MethodSignature>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    for (const el of node.parameters)
      this.visit(el, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
  }

  visitMethodDeclaration(node: Queryable<ts.MethodDeclaration>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.body !== undefined) {
      this.visit(node.body, node);
    }
    if (node.asteriskToken !== undefined) {
      this.visit(node.asteriskToken, node);
    }
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    for (const el of node.parameters)
      this.visit(el, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitConstructorDeclaration(node: Queryable<ts.ConstructorDeclaration>, parent: ts.Node | undefined) {
    if (node.body !== undefined) {
      this.visit(node.body, node);
    }
    if (node.asteriskToken !== undefined) {
      this.visit(node.asteriskToken, node);
    }
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    for (const el of node.parameters)
      this.visit(el, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitSemicolonClassElement(node: Queryable<ts.SemicolonClassElement>, parent: ts.Node | undefined) {
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitGetAccessorDeclaration(node: Queryable<ts.GetAccessorDeclaration>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    this.visit(node.body, node);
    if (node.asteriskToken !== undefined) {
      this.visit(node.asteriskToken, node);
    }
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    for (const el of node.parameters)
      this.visit(el, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitSetAccessorDeclaration(node: Queryable<ts.SetAccessorDeclaration>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    this.visit(node.body, node);
    if (node.asteriskToken !== undefined) {
      this.visit(node.asteriskToken, node);
    }
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    for (const el of node.parameters)
      this.visit(el, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitIndexSignatureDeclaration(node: Queryable<ts.IndexSignatureDeclaration>, parent: ts.Node | undefined) {
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    for (const el of node.parameters)
      this.visit(el, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
  }

  visitKeywordTypeNode(node: Queryable<ts.KeywordTypeNode>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitThisTypeNode(node: Queryable<ts.ThisTypeNode>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitFunctionTypeNode(node: Queryable<ts.FunctionTypeNode>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    for (const el of node.parameters)
      this.visit(el, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
  }

  visitConstructorTypeNode(node: Queryable<ts.ConstructorTypeNode>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    for (const el of node.parameters)
      this.visit(el, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
  }

  visitTypeReferenceNode(node: Queryable<ts.TypeReferenceNode>, parent: ts.Node | undefined) {
    this.visit(node.typeName, node);
    if (node.typeArguments !== undefined) {
      for (const el of node.typeArguments)
        this.visit(el, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTypePredicateNode(node: Queryable<ts.TypePredicateNode>, parent: ts.Node | undefined) {
    this.visit(node.parameterName, node);
    this.visit(node.type, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTypeQueryNode(node: Queryable<ts.TypeQueryNode>, parent: ts.Node | undefined) {
    this.visit(node.exprName, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTypeLiteralNode(node: Queryable<ts.TypeLiteralNode>, parent: ts.Node | undefined) {
    for (const el of node.members)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitArrayTypeNode(node: Queryable<ts.ArrayTypeNode>, parent: ts.Node | undefined) {
    this.visit(node.elementType, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTupleTypeNode(node: Queryable<ts.TupleTypeNode>, parent: ts.Node | undefined) {
    for (const el of node.elementTypes)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitUnionTypeNode(node: Queryable<ts.UnionTypeNode>, parent: ts.Node | undefined) {
    for (const el of node.types)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitIntersectionTypeNode(node: Queryable<ts.IntersectionTypeNode>, parent: ts.Node | undefined) {
    for (const el of node.types)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitParenthesizedTypeNode(node: Queryable<ts.ParenthesizedTypeNode>, parent: ts.Node | undefined) {
    this.visit(node.type, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTypeOperatorNode(node: Queryable<ts.TypeOperatorNode>, parent: ts.Node | undefined) {
    this.visit(node.type, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitIndexedAccessTypeNode(node: Queryable<ts.IndexedAccessTypeNode>, parent: ts.Node | undefined) {
    this.visit(node.objectType, node);
    this.visit(node.indexType, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitMappedTypeNode(node: Queryable<ts.MappedTypeNode>, parent: ts.Node | undefined) {
    if (node.readonlyToken !== undefined) {
      this.visit(node.readonlyToken, node);
    }
    this.visit(node.typeParameter, node);
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitLiteralTypeNode(node: Queryable<ts.LiteralTypeNode>, parent: ts.Node | undefined) {
    this.visit(node.literal, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitStringLiteral(node: Queryable<ts.StringLiteral>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitOmittedExpression(node: Queryable<ts.OmittedExpression>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitPartiallyEmittedExpression(node: Queryable<ts.PartiallyEmittedExpression>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitPrefixUnaryExpression(node: Queryable<ts.PrefixUnaryExpression>, parent: ts.Node | undefined) {
    this.visit(node.operand, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitPostfixUnaryExpression(node: Queryable<ts.PostfixUnaryExpression>, parent: ts.Node | undefined) {
    this.visit(node.operand, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitNullLiteral(node: Queryable<ts.NullLiteral>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitBooleanLiteral(node: Queryable<ts.BooleanLiteral>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitThisExpression(node: Queryable<ts.ThisExpression>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitSuperExpression(node: Queryable<ts.SuperExpression>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitImportExpression(node: Queryable<ts.ImportExpression>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitDeleteExpression(node: Queryable<ts.DeleteExpression>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTypeOfExpression(node: Queryable<ts.TypeOfExpression>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitVoidExpression(node: Queryable<ts.VoidExpression>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitAwaitExpression(node: Queryable<ts.AwaitExpression>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitYieldExpression(node: Queryable<ts.YieldExpression>, parent: ts.Node | undefined) {
    if (node.asteriskToken !== undefined) {
      this.visit(node.asteriskToken, node);
    }
    if (node.expression !== undefined) {
      this.visit(node.expression, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitBinaryExpression(node: Queryable<ts.BinaryExpression>, parent: ts.Node | undefined) {
    this.visit(node.left, node);
    this.visit(node.operatorToken, node);
    this.visit(node.right, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitConditionalExpression(node: Queryable<ts.ConditionalExpression>, parent: ts.Node | undefined) {
    this.visit(node.condition, node);
    this.visit(node.questionToken, node);
    this.visit(node.whenTrue, node);
    this.visit(node.colonToken, node);
    this.visit(node.whenFalse, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitFunctionExpression(node: Queryable<ts.FunctionExpression>, parent: ts.Node | undefined) {
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    this.visit(node.body, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
    if (node.asteriskToken !== undefined) {
      this.visit(node.asteriskToken, node);
    }
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    for (const el of node.parameters)
      this.visit(el, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
  }

  visitArrowFunction(node: Queryable<ts.ArrowFunction>, parent: ts.Node | undefined) {
    this.visit(node.equalsGreaterThanToken, node);
    this.visit(node.body, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
    if (node.asteriskToken !== undefined) {
      this.visit(node.asteriskToken, node);
    }
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    for (const el of node.parameters)
      this.visit(el, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
  }

  visitRegularExpressionLiteral(node: Queryable<ts.RegularExpressionLiteral>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitNoSubstitutionTemplateLiteral(node: Queryable<ts.NoSubstitutionTemplateLiteral>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitNumericLiteral(node: Queryable<ts.NumericLiteral>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTemplateHead(node: Queryable<ts.TemplateHead>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTemplateMiddle(node: Queryable<ts.TemplateMiddle>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTemplateTail(node: Queryable<ts.TemplateTail>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTemplateExpression(node: Queryable<ts.TemplateExpression>, parent: ts.Node | undefined) {
    this.visit(node.head, node);
    for (const el of node.templateSpans)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTemplateSpan(node: Queryable<ts.TemplateSpan>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    this.visit(node.literal, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitParenthesizedExpression(node: Queryable<ts.ParenthesizedExpression>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitArrayLiteralExpression(node: Queryable<ts.ArrayLiteralExpression>, parent: ts.Node | undefined) {
    for (const el of node.elements)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitSpreadElement(node: Queryable<ts.SpreadElement>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitObjectLiteralExpression(node: Queryable<ts.ObjectLiteralExpression>, parent: ts.Node | undefined) {
    for (const el of node.properties)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitPropertyAccessExpression(node: Queryable<ts.PropertyAccessExpression>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    this.visit(node.name, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitElementAccessExpression(node: Queryable<ts.ElementAccessExpression>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.argumentExpression !== undefined) {
      this.visit(node.argumentExpression, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitCallExpression(node: Queryable<ts.CallExpression>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.typeArguments !== undefined) {
      for (const el of node.typeArguments)
        this.visit(el, node);
    }
    for (const el of node.arguments)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitExpressionWithTypeArguments(node: Queryable<ts.ExpressionWithTypeArguments>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.typeArguments !== undefined) {
      for (const el of node.typeArguments)
        this.visit(el, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitNewExpression(node: Queryable<ts.NewExpression>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.typeArguments !== undefined) {
      for (const el of node.typeArguments)
        this.visit(el, node);
    }
    if (node.arguments !== undefined) {
      for (const el of node.arguments)
        this.visit(el, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTaggedTemplateExpression(node: Queryable<ts.TaggedTemplateExpression>, parent: ts.Node | undefined) {
    this.visit(node.tag, node);
    this.visit(node.template, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitAsExpression(node: Queryable<ts.AsExpression>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    this.visit(node.type, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTypeAssertion(node: Queryable<ts.TypeAssertion>, parent: ts.Node | undefined) {
    this.visit(node.type, node);
    this.visit(node.expression, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitNonNullExpression(node: Queryable<ts.NonNullExpression>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitMetaProperty(node: Queryable<ts.MetaProperty>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJsxElement(node: Queryable<ts.JsxElement>, parent: ts.Node | undefined) {
    this.visit(node.openingElement, node);
    for (const el of node.children)
      this.visit(el, node);
    this.visit(node.closingElement, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJsxOpeningElement(node: Queryable<ts.JsxOpeningElement>, parent: ts.Node | undefined) {
    this.visit(node.tagName, node);
    this.visit(node.attributes, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJsxSelfClosingElement(node: Queryable<ts.JsxSelfClosingElement>, parent: ts.Node | undefined) {
    this.visit(node.tagName, node);
    this.visit(node.attributes, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJsxAttribute(node: Queryable<ts.JsxAttribute>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.initializer !== undefined) {
      this.visit(node.initializer, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJsxSpreadAttribute(node: Queryable<ts.JsxSpreadAttribute>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJsxClosingElement(node: Queryable<ts.JsxClosingElement>, parent: ts.Node | undefined) {
    this.visit(node.tagName, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJsxExpression(node: Queryable<ts.JsxExpression>, parent: ts.Node | undefined) {
    if (node.dotDotDotToken !== undefined) {
      this.visit(node.dotDotDotToken, node);
    }
    if (node.expression !== undefined) {
      this.visit(node.expression, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJsxText(node: Queryable<ts.JsxText>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitNotEmittedStatement(node: Queryable<ts.NotEmittedStatement>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitCommaListExpression(node: Queryable<ts.CommaListExpression>, parent: ts.Node | undefined) {
    for (const el of node.elements)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitEmptyStatement(node: Queryable<ts.EmptyStatement>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitDebuggerStatement(node: Queryable<ts.DebuggerStatement>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitMissingDeclaration(node: Queryable<ts.MissingDeclaration>, parent: ts.Node | undefined) {
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
  }

  visitBlock(node: Queryable<ts.Block>, parent: ts.Node | undefined) {
    for (const el of node.statements)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitVariableStatement(node: Queryable<ts.VariableStatement>, parent: ts.Node | undefined) {
    this.visit(node.declarationList, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitExpressionStatement(node: Queryable<ts.ExpressionStatement>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitIfStatement(node: Queryable<ts.IfStatement>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    this.visit(node.thenStatement, node);
    if (node.elseStatement !== undefined) {
      this.visit(node.elseStatement, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitDoStatement(node: Queryable<ts.DoStatement>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    this.visit(node.statement, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitWhileStatement(node: Queryable<ts.WhileStatement>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    this.visit(node.statement, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitForStatement(node: Queryable<ts.ForStatement>, parent: ts.Node | undefined) {
    if (node.initializer !== undefined) {
      this.visit(node.initializer, node);
    }
    if (node.condition !== undefined) {
      this.visit(node.condition, node);
    }
    if (node.incrementor !== undefined) {
      this.visit(node.incrementor, node);
    }
    this.visit(node.statement, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitForInStatement(node: Queryable<ts.ForInStatement>, parent: ts.Node | undefined) {
    this.visit(node.initializer, node);
    this.visit(node.expression, node);
    this.visit(node.statement, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitForOfStatement(node: Queryable<ts.ForOfStatement>, parent: ts.Node | undefined) {
    if (node.awaitModifier !== undefined) {
      this.visit(node.awaitModifier, node);
    }
    this.visit(node.initializer, node);
    this.visit(node.expression, node);
    this.visit(node.statement, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitBreakStatement(node: Queryable<ts.BreakStatement>, parent: ts.Node | undefined) {
    if (node.label !== undefined) {
      this.visit(node.label, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitContinueStatement(node: Queryable<ts.ContinueStatement>, parent: ts.Node | undefined) {
    if (node.label !== undefined) {
      this.visit(node.label, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitReturnStatement(node: Queryable<ts.ReturnStatement>, parent: ts.Node | undefined) {
    if (node.expression !== undefined) {
      this.visit(node.expression, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitWithStatement(node: Queryable<ts.WithStatement>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    this.visit(node.statement, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitSwitchStatement(node: Queryable<ts.SwitchStatement>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    this.visit(node.caseBlock, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitCaseBlock(node: Queryable<ts.CaseBlock>, parent: ts.Node | undefined) {
    for (const el of node.clauses)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitCaseClause(node: Queryable<ts.CaseClause>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    for (const el of node.statements)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitDefaultClause(node: Queryable<ts.DefaultClause>, parent: ts.Node | undefined) {
    for (const el of node.statements)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitLabeledStatement(node: Queryable<ts.LabeledStatement>, parent: ts.Node | undefined) {
    this.visit(node.label, node);
    this.visit(node.statement, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitThrowStatement(node: Queryable<ts.ThrowStatement>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTryStatement(node: Queryable<ts.TryStatement>, parent: ts.Node | undefined) {
    this.visit(node.tryBlock, node);
    if (node.catchClause !== undefined) {
      this.visit(node.catchClause, node);
    }
    if (node.finallyBlock !== undefined) {
      this.visit(node.finallyBlock, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitCatchClause(node: Queryable<ts.CatchClause>, parent: ts.Node | undefined) {
    this.visit(node.variableDeclaration, node);
    this.visit(node.block, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitClassDeclaration(node: Queryable<ts.ClassDeclaration>, parent: ts.Node | undefined) {
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    if (node.heritageClauses !== undefined) {
      for (const el of node.heritageClauses)
        this.visit(el, node);
    }
    for (const el of node.members)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitClassExpression(node: Queryable<ts.ClassExpression>, parent: ts.Node | undefined) {
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    if (node.heritageClauses !== undefined) {
      for (const el of node.heritageClauses)
        this.visit(el, node);
    }
    for (const el of node.members)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitInterfaceDeclaration(node: Queryable<ts.InterfaceDeclaration>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    if (node.heritageClauses !== undefined) {
      for (const el of node.heritageClauses)
        this.visit(el, node);
    }
    for (const el of node.members)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitHeritageClause(node: Queryable<ts.HeritageClause>, parent: ts.Node | undefined) {
    for (const el of node.types)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitTypeAliasDeclaration(node: Queryable<ts.TypeAliasDeclaration>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
    this.visit(node.type, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitEnumMember(node: Queryable<ts.EnumMember>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.initializer !== undefined) {
      this.visit(node.initializer, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitEnumDeclaration(node: Queryable<ts.EnumDeclaration>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    for (const el of node.members)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitModuleDeclaration(node: Queryable<ts.ModuleDeclaration>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.body !== undefined) {
      this.visit(node.body, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitModuleBlock(node: Queryable<ts.ModuleBlock>, parent: ts.Node | undefined) {
    for (const el of node.statements)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitImportEqualsDeclaration(node: Queryable<ts.ImportEqualsDeclaration>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    this.visit(node.moduleReference, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitExternalModuleReference(node: Queryable<ts.ExternalModuleReference>, parent: ts.Node | undefined) {
    if (node.expression !== undefined) {
      this.visit(node.expression, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitImportDeclaration(node: Queryable<ts.ImportDeclaration>, parent: ts.Node | undefined) {
    if (node.importClause !== undefined) {
      this.visit(node.importClause, node);
    }
    this.visit(node.moduleSpecifier, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitImportClause(node: Queryable<ts.ImportClause>, parent: ts.Node | undefined) {
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.namedBindings !== undefined) {
      this.visit(node.namedBindings, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitNamespaceImport(node: Queryable<ts.NamespaceImport>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitNamespaceExportDeclaration(node: Queryable<ts.NamespaceExportDeclaration>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitExportDeclaration(node: Queryable<ts.ExportDeclaration>, parent: ts.Node | undefined) {
    if (node.exportClause !== undefined) {
      this.visit(node.exportClause, node);
    }
    if (node.moduleSpecifier !== undefined) {
      this.visit(node.moduleSpecifier, node);
    }
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitNamedImports(node: Queryable<ts.NamedImports>, parent: ts.Node | undefined) {
    for (const el of node.elements)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitNamedExports(node: Queryable<ts.NamedExports>, parent: ts.Node | undefined) {
    for (const el of node.elements)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitImportSpecifier(node: Queryable<ts.ImportSpecifier>, parent: ts.Node | undefined) {
    if (node.propertyName !== undefined) {
      this.visit(node.propertyName, node);
    }
    this.visit(node.name, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitExportSpecifier(node: Queryable<ts.ExportSpecifier>, parent: ts.Node | undefined) {
    if (node.propertyName !== undefined) {
      this.visit(node.propertyName, node);
    }
    this.visit(node.name, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitExportAssignment(node: Queryable<ts.ExportAssignment>, parent: ts.Node | undefined) {
    this.visit(node.expression, node);
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocTypeExpression(node: Queryable<ts.JSDocTypeExpression>, parent: ts.Node | undefined) {
    this.visit(node.type, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocAllType(node: Queryable<ts.JSDocAllType>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocUnknownType(node: Queryable<ts.JSDocUnknownType>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocArrayType(node: Queryable<ts.JSDocArrayType>, parent: ts.Node | undefined) {
    this.visit(node.elementType, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocUnionType(node: Queryable<ts.JSDocUnionType>, parent: ts.Node | undefined) {
    for (const el of node.types)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocTupleType(node: Queryable<ts.JSDocTupleType>, parent: ts.Node | undefined) {
    for (const el of node.types)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocNonNullableType(node: Queryable<ts.JSDocNonNullableType>, parent: ts.Node | undefined) {
    this.visit(node.type, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocNullableType(node: Queryable<ts.JSDocNullableType>, parent: ts.Node | undefined) {
    this.visit(node.type, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocRecordType(node: Queryable<ts.JSDocRecordType>, parent: ts.Node | undefined) {
    this.visit(node.literal, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocTypeReference(node: Queryable<ts.JSDocTypeReference>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    for (const el of node.typeArguments)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocOptionalType(node: Queryable<ts.JSDocOptionalType>, parent: ts.Node | undefined) {
    this.visit(node.type, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocFunctionType(node: Queryable<ts.JSDocFunctionType>, parent: ts.Node | undefined) {
    for (const el of node.parameters)
      this.visit(el, node);
    this.visit(node.type, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.typeParameters !== undefined) {
      for (const el of node.typeParameters)
        this.visit(el, node);
    }
  }

  visitJSDocVariadicType(node: Queryable<ts.JSDocVariadicType>, parent: ts.Node | undefined) {
    this.visit(node.type, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocConstructorType(node: Queryable<ts.JSDocConstructorType>, parent: ts.Node | undefined) {
    this.visit(node.type, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocThisType(node: Queryable<ts.JSDocThisType>, parent: ts.Node | undefined) {
    this.visit(node.type, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocLiteralType(node: Queryable<ts.JSDocLiteralType>, parent: ts.Node | undefined) {
    this.visit(node.literal, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocRecordMember(node: Queryable<ts.JSDocRecordMember>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.type !== undefined) {
      this.visit(node.type, node);
    }
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
    if (node.initializer !== undefined) {
      this.visit(node.initializer, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDoc(node: Queryable<ts.JSDoc>, parent: ts.Node | undefined) {
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocUnknownTag(node: Queryable<ts.JSDocUnknownTag>, parent: ts.Node | undefined) {
    this.visit(node.atToken, node);
    this.visit(node.tagName, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocAugmentsTag(node: Queryable<ts.JSDocAugmentsTag>, parent: ts.Node | undefined) {
    this.visit(node.typeExpression, node);
    this.visit(node.atToken, node);
    this.visit(node.tagName, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocClassTag(node: Queryable<ts.JSDocClassTag>, parent: ts.Node | undefined) {
    this.visit(node.atToken, node);
    this.visit(node.tagName, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocTemplateTag(node: Queryable<ts.JSDocTemplateTag>, parent: ts.Node | undefined) {
    for (const el of node.typeParameters)
      this.visit(el, node);
    this.visit(node.atToken, node);
    this.visit(node.tagName, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocReturnTag(node: Queryable<ts.JSDocReturnTag>, parent: ts.Node | undefined) {
    this.visit(node.typeExpression, node);
    this.visit(node.atToken, node);
    this.visit(node.tagName, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocTypeTag(node: Queryable<ts.JSDocTypeTag>, parent: ts.Node | undefined) {
    this.visit(node.typeExpression, node);
    this.visit(node.atToken, node);
    this.visit(node.tagName, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocTypedefTag(node: Queryable<ts.JSDocTypedefTag>, parent: ts.Node | undefined) {
    if (node.fullName !== undefined) {
      this.visit(node.fullName, node);
    }
    if (node.name !== undefined) {
      this.visit(node.name, node);
    }
    if (node.typeExpression !== undefined) {
      this.visit(node.typeExpression, node);
    }
    if (node.jsDocTypeLiteral !== undefined) {
      this.visit(node.jsDocTypeLiteral, node);
    }
    this.visit(node.atToken, node);
    this.visit(node.tagName, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocPropertyTag(node: Queryable<ts.JSDocPropertyTag>, parent: ts.Node | undefined) {
    this.visit(node.name, node);
    if (node.preParameterName !== undefined) {
      this.visit(node.preParameterName, node);
    }
    if (node.postParameterName !== undefined) {
      this.visit(node.postParameterName, node);
    }
    this.visit(node.typeExpression, node);
    this.visit(node.atToken, node);
    this.visit(node.tagName, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
    if (node.questionToken !== undefined) {
      this.visit(node.questionToken, node);
    }
  }

  visitJSDocTypeLiteral(node: Queryable<ts.JSDocTypeLiteral>, parent: ts.Node | undefined) {
    if (node.jsDocPropertyTags !== undefined) {
      for (const el of node.jsDocPropertyTags)
        this.visit(el, node);
    }
    if (node.jsDocTypeTag !== undefined) {
      this.visit(node.jsDocTypeTag, node);
    }
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitJSDocParameterTag(node: Queryable<ts.JSDocParameterTag>, parent: ts.Node | undefined) {
    if (node.preParameterName !== undefined) {
      this.visit(node.preParameterName, node);
    }
    if (node.typeExpression !== undefined) {
      this.visit(node.typeExpression, node);
    }
    if (node.postParameterName !== undefined) {
      this.visit(node.postParameterName, node);
    }
    this.visit(node.name, node);
    this.visit(node.atToken, node);
    this.visit(node.tagName, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitSourceFile(node: Queryable<ts.SourceFile>, parent: ts.Node | undefined) {
    for (const el of node.statements)
      this.visit(el, node);
    this.visit(node.endOfFileToken, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visitBundle(node: Queryable<ts.Bundle>, parent: ts.Node | undefined) {
    for (const el of node.sourceFiles)
      this.visit(el, node);
    if (node.decorators !== undefined) {
      for (const el of node.decorators)
        this.visit(el, node);
    }
    if (node.modifiers !== undefined) {
      for (const el of node.modifiers)
        this.visit(el, node);
    }
  }

  visit(val: Queryable<ts.Node>, parent?: ts.Node) {
    switch(val.kind) {
    case ts.SyntaxKind.NumericLiteral:
      this.visitNumericLiteral(<ts.NumericLiteral>val, parent)
      break;
    case ts.SyntaxKind.StringLiteral:
      this.visitStringLiteral(<ts.StringLiteral>val, parent)
      break;
    case ts.SyntaxKind.JsxText:
      this.visitJsxText(<ts.JsxText>val, parent)
      break;
    case ts.SyntaxKind.RegularExpressionLiteral:
      this.visitRegularExpressionLiteral(<ts.RegularExpressionLiteral>val, parent)
      break;
    case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
      this.visitNoSubstitutionTemplateLiteral(<ts.NoSubstitutionTemplateLiteral>val, parent)
      break;
    case ts.SyntaxKind.TemplateHead:
      this.visitTemplateHead(<ts.TemplateHead>val, parent)
      break;
    case ts.SyntaxKind.TemplateMiddle:
      this.visitTemplateMiddle(<ts.TemplateMiddle>val, parent)
      break;
    case ts.SyntaxKind.TemplateTail:
      this.visitTemplateTail(<ts.TemplateTail>val, parent)
      break;
    case ts.SyntaxKind.Identifier:
      this.visitIdentifier(<ts.Identifier>val, parent)
      break;
    case ts.SyntaxKind.ImportKeyword:
      this.visitImportExpression(<ts.ImportExpression>val, parent)
      break;
    case ts.SyntaxKind.NullKeyword:
      this.visitNullLiteral(<ts.NullLiteral>val, parent)
      break;
    case ts.SyntaxKind.SuperKeyword:
      this.visitSuperExpression(<ts.SuperExpression>val, parent)
      break;
    case ts.SyntaxKind.ThisKeyword:
      this.visitThisExpression(<ts.ThisExpression>val, parent)
      break;
    case ts.SyntaxKind.QualifiedName:
      this.visitQualifiedName(<ts.QualifiedName>val, parent)
      break;
    case ts.SyntaxKind.ComputedPropertyName:
      this.visitComputedPropertyName(<ts.ComputedPropertyName>val, parent)
      break;
    case ts.SyntaxKind.TypeParameter:
      this.visitTypeParameterDeclaration(<ts.TypeParameterDeclaration>val, parent)
      break;
    case ts.SyntaxKind.Parameter:
      this.visitParameterDeclaration(<ts.ParameterDeclaration>val, parent)
      break;
    case ts.SyntaxKind.Decorator:
      this.visitDecorator(<ts.Decorator>val, parent)
      break;
    case ts.SyntaxKind.PropertyDeclaration:
      this.visitPropertyDeclaration(<ts.PropertyDeclaration>val, parent)
      break;
    case ts.SyntaxKind.MethodSignature:
      this.visitMethodSignature(<ts.MethodSignature>val, parent)
      break;
    case ts.SyntaxKind.MethodDeclaration:
      this.visitMethodDeclaration(<ts.MethodDeclaration>val, parent)
      break;
    case ts.SyntaxKind.Constructor:
      this.visitConstructorDeclaration(<ts.ConstructorDeclaration>val, parent)
      break;
    case ts.SyntaxKind.GetAccessor:
      this.visitGetAccessorDeclaration(<ts.GetAccessorDeclaration>val, parent)
      break;
    case ts.SyntaxKind.SetAccessor:
      this.visitSetAccessorDeclaration(<ts.SetAccessorDeclaration>val, parent)
      break;
    case ts.SyntaxKind.CallSignature:
      this.visitCallSignatureDeclaration(<ts.CallSignatureDeclaration>val, parent)
      break;
    case ts.SyntaxKind.ConstructSignature:
      this.visitConstructSignatureDeclaration(<ts.ConstructSignatureDeclaration>val, parent)
      break;
    case ts.SyntaxKind.IndexSignature:
      this.visitIndexSignatureDeclaration(<ts.IndexSignatureDeclaration>val, parent)
      break;
    case ts.SyntaxKind.TypePredicate:
      this.visitTypePredicateNode(<ts.TypePredicateNode>val, parent)
      break;
    case ts.SyntaxKind.TypeReference:
      this.visitTypeReferenceNode(<ts.TypeReferenceNode>val, parent)
      break;
    case ts.SyntaxKind.FunctionType:
      this.visitFunctionTypeNode(<ts.FunctionTypeNode>val, parent)
      break;
    case ts.SyntaxKind.ConstructorType:
      this.visitConstructorTypeNode(<ts.ConstructorTypeNode>val, parent)
      break;
    case ts.SyntaxKind.TypeQuery:
      this.visitTypeQueryNode(<ts.TypeQueryNode>val, parent)
      break;
    case ts.SyntaxKind.TypeLiteral:
      this.visitTypeLiteralNode(<ts.TypeLiteralNode>val, parent)
      break;
    case ts.SyntaxKind.ArrayType:
      this.visitArrayTypeNode(<ts.ArrayTypeNode>val, parent)
      break;
    case ts.SyntaxKind.TupleType:
      this.visitTupleTypeNode(<ts.TupleTypeNode>val, parent)
      break;
    case ts.SyntaxKind.UnionType:
      this.visitUnionTypeNode(<ts.UnionTypeNode>val, parent)
      break;
    case ts.SyntaxKind.IntersectionType:
      this.visitIntersectionTypeNode(<ts.IntersectionTypeNode>val, parent)
      break;
    case ts.SyntaxKind.ParenthesizedType:
      this.visitParenthesizedTypeNode(<ts.ParenthesizedTypeNode>val, parent)
      break;
    case ts.SyntaxKind.ThisType:
      this.visitThisTypeNode(<ts.ThisTypeNode>val, parent)
      break;
    case ts.SyntaxKind.TypeOperator:
      this.visitTypeOperatorNode(<ts.TypeOperatorNode>val, parent)
      break;
    case ts.SyntaxKind.IndexedAccessType:
      this.visitIndexedAccessTypeNode(<ts.IndexedAccessTypeNode>val, parent)
      break;
    case ts.SyntaxKind.MappedType:
      this.visitMappedTypeNode(<ts.MappedTypeNode>val, parent)
      break;
    case ts.SyntaxKind.LiteralType:
      this.visitLiteralTypeNode(<ts.LiteralTypeNode>val, parent)
      break;
    case ts.SyntaxKind.ObjectBindingPattern:
      this.visitObjectBindingPattern(<ts.ObjectBindingPattern>val, parent)
      break;
    case ts.SyntaxKind.ArrayBindingPattern:
      this.visitArrayBindingPattern(<ts.ArrayBindingPattern>val, parent)
      break;
    case ts.SyntaxKind.BindingElement:
      this.visitBindingElement(<ts.BindingElement>val, parent)
      break;
    case ts.SyntaxKind.ArrayLiteralExpression:
      this.visitArrayLiteralExpression(<ts.ArrayLiteralExpression>val, parent)
      break;
    case ts.SyntaxKind.ObjectLiteralExpression:
      this.visitObjectLiteralExpression(<ts.ObjectLiteralExpression>val, parent)
      break;
    case ts.SyntaxKind.PropertyAccessExpression:
      this.visitPropertyAccessExpression(<ts.PropertyAccessExpression>val, parent)
      break;
    case ts.SyntaxKind.ElementAccessExpression:
      this.visitElementAccessExpression(<ts.ElementAccessExpression>val, parent)
      break;
    case ts.SyntaxKind.CallExpression:
      this.visitCallExpression(<ts.CallExpression>val, parent)
      break;
    case ts.SyntaxKind.NewExpression:
      this.visitNewExpression(<ts.NewExpression>val, parent)
      break;
    case ts.SyntaxKind.TaggedTemplateExpression:
      this.visitTaggedTemplateExpression(<ts.TaggedTemplateExpression>val, parent)
      break;
    case ts.SyntaxKind.TypeAssertionExpression:
      this.visitTypeAssertion(<ts.TypeAssertion>val, parent)
      break;
    case ts.SyntaxKind.ParenthesizedExpression:
      this.visitParenthesizedExpression(<ts.ParenthesizedExpression>val, parent)
      break;
    case ts.SyntaxKind.FunctionExpression:
      this.visitFunctionExpression(<ts.FunctionExpression>val, parent)
      break;
    case ts.SyntaxKind.ArrowFunction:
      this.visitArrowFunction(<ts.ArrowFunction>val, parent)
      break;
    case ts.SyntaxKind.DeleteExpression:
      this.visitDeleteExpression(<ts.DeleteExpression>val, parent)
      break;
    case ts.SyntaxKind.TypeOfExpression:
      this.visitTypeOfExpression(<ts.TypeOfExpression>val, parent)
      break;
    case ts.SyntaxKind.VoidExpression:
      this.visitVoidExpression(<ts.VoidExpression>val, parent)
      break;
    case ts.SyntaxKind.AwaitExpression:
      this.visitAwaitExpression(<ts.AwaitExpression>val, parent)
      break;
    case ts.SyntaxKind.PrefixUnaryExpression:
      this.visitPrefixUnaryExpression(<ts.PrefixUnaryExpression>val, parent)
      break;
    case ts.SyntaxKind.PostfixUnaryExpression:
      this.visitPostfixUnaryExpression(<ts.PostfixUnaryExpression>val, parent)
      break;
    case ts.SyntaxKind.BinaryExpression:
      this.visitBinaryExpression(<ts.BinaryExpression>val, parent)
      break;
    case ts.SyntaxKind.ConditionalExpression:
      this.visitConditionalExpression(<ts.ConditionalExpression>val, parent)
      break;
    case ts.SyntaxKind.TemplateExpression:
      this.visitTemplateExpression(<ts.TemplateExpression>val, parent)
      break;
    case ts.SyntaxKind.YieldExpression:
      this.visitYieldExpression(<ts.YieldExpression>val, parent)
      break;
    case ts.SyntaxKind.SpreadElement:
      this.visitSpreadElement(<ts.SpreadElement>val, parent)
      break;
    case ts.SyntaxKind.ClassExpression:
      this.visitClassExpression(<ts.ClassExpression>val, parent)
      break;
    case ts.SyntaxKind.OmittedExpression:
      this.visitOmittedExpression(<ts.OmittedExpression>val, parent)
      break;
    case ts.SyntaxKind.ExpressionWithTypeArguments:
      this.visitExpressionWithTypeArguments(<ts.ExpressionWithTypeArguments>val, parent)
      break;
    case ts.SyntaxKind.AsExpression:
      this.visitAsExpression(<ts.AsExpression>val, parent)
      break;
    case ts.SyntaxKind.NonNullExpression:
      this.visitNonNullExpression(<ts.NonNullExpression>val, parent)
      break;
    case ts.SyntaxKind.MetaProperty:
      this.visitMetaProperty(<ts.MetaProperty>val, parent)
      break;
    case ts.SyntaxKind.TemplateSpan:
      this.visitTemplateSpan(<ts.TemplateSpan>val, parent)
      break;
    case ts.SyntaxKind.SemicolonClassElement:
      this.visitSemicolonClassElement(<ts.SemicolonClassElement>val, parent)
      break;
    case ts.SyntaxKind.Block:
      this.visitBlock(<ts.Block>val, parent)
      break;
    case ts.SyntaxKind.VariableStatement:
      this.visitVariableStatement(<ts.VariableStatement>val, parent)
      break;
    case ts.SyntaxKind.EmptyStatement:
      this.visitEmptyStatement(<ts.EmptyStatement>val, parent)
      break;
    case ts.SyntaxKind.ExpressionStatement:
      this.visitExpressionStatement(<ts.ExpressionStatement>val, parent)
      break;
    case ts.SyntaxKind.IfStatement:
      this.visitIfStatement(<ts.IfStatement>val, parent)
      break;
    case ts.SyntaxKind.DoStatement:
      this.visitDoStatement(<ts.DoStatement>val, parent)
      break;
    case ts.SyntaxKind.WhileStatement:
      this.visitWhileStatement(<ts.WhileStatement>val, parent)
      break;
    case ts.SyntaxKind.ForStatement:
      this.visitForStatement(<ts.ForStatement>val, parent)
      break;
    case ts.SyntaxKind.ForInStatement:
      this.visitForInStatement(<ts.ForInStatement>val, parent)
      break;
    case ts.SyntaxKind.ForOfStatement:
      this.visitForOfStatement(<ts.ForOfStatement>val, parent)
      break;
    case ts.SyntaxKind.ContinueStatement:
      this.visitContinueStatement(<ts.ContinueStatement>val, parent)
      break;
    case ts.SyntaxKind.BreakStatement:
      this.visitBreakStatement(<ts.BreakStatement>val, parent)
      break;
    case ts.SyntaxKind.ReturnStatement:
      this.visitReturnStatement(<ts.ReturnStatement>val, parent)
      break;
    case ts.SyntaxKind.WithStatement:
      this.visitWithStatement(<ts.WithStatement>val, parent)
      break;
    case ts.SyntaxKind.SwitchStatement:
      this.visitSwitchStatement(<ts.SwitchStatement>val, parent)
      break;
    case ts.SyntaxKind.LabeledStatement:
      this.visitLabeledStatement(<ts.LabeledStatement>val, parent)
      break;
    case ts.SyntaxKind.ThrowStatement:
      this.visitThrowStatement(<ts.ThrowStatement>val, parent)
      break;
    case ts.SyntaxKind.TryStatement:
      this.visitTryStatement(<ts.TryStatement>val, parent)
      break;
    case ts.SyntaxKind.DebuggerStatement:
      this.visitDebuggerStatement(<ts.DebuggerStatement>val, parent)
      break;
    case ts.SyntaxKind.VariableDeclaration:
      this.visitVariableDeclaration(<ts.VariableDeclaration>val, parent)
      break;
    case ts.SyntaxKind.VariableDeclarationList:
      this.visitVariableDeclarationList(<ts.VariableDeclarationList>val, parent)
      break;
    case ts.SyntaxKind.FunctionDeclaration:
      this.visitFunctionDeclaration(<ts.FunctionDeclaration>val, parent)
      break;
    case ts.SyntaxKind.ClassDeclaration:
      this.visitClassDeclaration(<ts.ClassDeclaration>val, parent)
      break;
    case ts.SyntaxKind.InterfaceDeclaration:
      this.visitInterfaceDeclaration(<ts.InterfaceDeclaration>val, parent)
      break;
    case ts.SyntaxKind.TypeAliasDeclaration:
      this.visitTypeAliasDeclaration(<ts.TypeAliasDeclaration>val, parent)
      break;
    case ts.SyntaxKind.EnumDeclaration:
      this.visitEnumDeclaration(<ts.EnumDeclaration>val, parent)
      break;
    case ts.SyntaxKind.ModuleDeclaration:
      this.visitModuleDeclaration(<ts.ModuleDeclaration>val, parent)
      break;
    case ts.SyntaxKind.ModuleBlock:
      this.visitModuleBlock(<ts.ModuleBlock>val, parent)
      break;
    case ts.SyntaxKind.CaseBlock:
      this.visitCaseBlock(<ts.CaseBlock>val, parent)
      break;
    case ts.SyntaxKind.NamespaceExportDeclaration:
      this.visitNamespaceExportDeclaration(<ts.NamespaceExportDeclaration>val, parent)
      break;
    case ts.SyntaxKind.ImportEqualsDeclaration:
      this.visitImportEqualsDeclaration(<ts.ImportEqualsDeclaration>val, parent)
      break;
    case ts.SyntaxKind.ImportDeclaration:
      this.visitImportDeclaration(<ts.ImportDeclaration>val, parent)
      break;
    case ts.SyntaxKind.ImportClause:
      this.visitImportClause(<ts.ImportClause>val, parent)
      break;
    case ts.SyntaxKind.NamespaceImport:
      this.visitNamespaceImport(<ts.NamespaceImport>val, parent)
      break;
    case ts.SyntaxKind.NamedImports:
      this.visitNamedImports(<ts.NamedImports>val, parent)
      break;
    case ts.SyntaxKind.ImportSpecifier:
      this.visitImportSpecifier(<ts.ImportSpecifier>val, parent)
      break;
    case ts.SyntaxKind.ExportAssignment:
      this.visitExportAssignment(<ts.ExportAssignment>val, parent)
      break;
    case ts.SyntaxKind.ExportDeclaration:
      this.visitExportDeclaration(<ts.ExportDeclaration>val, parent)
      break;
    case ts.SyntaxKind.NamedExports:
      this.visitNamedExports(<ts.NamedExports>val, parent)
      break;
    case ts.SyntaxKind.ExportSpecifier:
      this.visitExportSpecifier(<ts.ExportSpecifier>val, parent)
      break;
    case ts.SyntaxKind.MissingDeclaration:
      this.visitMissingDeclaration(<ts.MissingDeclaration>val, parent)
      break;
    case ts.SyntaxKind.ExternalModuleReference:
      this.visitExternalModuleReference(<ts.ExternalModuleReference>val, parent)
      break;
    case ts.SyntaxKind.JsxElement:
      this.visitJsxElement(<ts.JsxElement>val, parent)
      break;
    case ts.SyntaxKind.JsxSelfClosingElement:
      this.visitJsxSelfClosingElement(<ts.JsxSelfClosingElement>val, parent)
      break;
    case ts.SyntaxKind.JsxOpeningElement:
      this.visitJsxOpeningElement(<ts.JsxOpeningElement>val, parent)
      break;
    case ts.SyntaxKind.JsxClosingElement:
      this.visitJsxClosingElement(<ts.JsxClosingElement>val, parent)
      break;
    case ts.SyntaxKind.JsxAttribute:
      this.visitJsxAttribute(<ts.JsxAttribute>val, parent)
      break;
    case ts.SyntaxKind.JsxSpreadAttribute:
      this.visitJsxSpreadAttribute(<ts.JsxSpreadAttribute>val, parent)
      break;
    case ts.SyntaxKind.JsxExpression:
      this.visitJsxExpression(<ts.JsxExpression>val, parent)
      break;
    case ts.SyntaxKind.CaseClause:
      this.visitCaseClause(<ts.CaseClause>val, parent)
      break;
    case ts.SyntaxKind.DefaultClause:
      this.visitDefaultClause(<ts.DefaultClause>val, parent)
      break;
    case ts.SyntaxKind.HeritageClause:
      this.visitHeritageClause(<ts.HeritageClause>val, parent)
      break;
    case ts.SyntaxKind.CatchClause:
      this.visitCatchClause(<ts.CatchClause>val, parent)
      break;
    case ts.SyntaxKind.PropertyAssignment:
      this.visitPropertyAssignment(<ts.PropertyAssignment>val, parent)
      break;
    case ts.SyntaxKind.ShorthandPropertyAssignment:
      this.visitShorthandPropertyAssignment(<ts.ShorthandPropertyAssignment>val, parent)
      break;
    case ts.SyntaxKind.SpreadAssignment:
      this.visitSpreadAssignment(<ts.SpreadAssignment>val, parent)
      break;
    case ts.SyntaxKind.EnumMember:
      this.visitEnumMember(<ts.EnumMember>val, parent)
      break;
    case ts.SyntaxKind.SourceFile:
      this.visitSourceFile(<ts.SourceFile>val, parent)
      break;
    case ts.SyntaxKind.Bundle:
      this.visitBundle(<ts.Bundle>val, parent)
      break;
    case ts.SyntaxKind.JSDocTypeExpression:
      this.visitJSDocTypeExpression(<ts.JSDocTypeExpression>val, parent)
      break;
    case ts.SyntaxKind.JSDocAllType:
      this.visitJSDocAllType(<ts.JSDocAllType>val, parent)
      break;
    case ts.SyntaxKind.JSDocUnknownType:
      this.visitJSDocUnknownType(<ts.JSDocUnknownType>val, parent)
      break;
    case ts.SyntaxKind.JSDocArrayType:
      this.visitJSDocArrayType(<ts.JSDocArrayType>val, parent)
      break;
    case ts.SyntaxKind.JSDocUnionType:
      this.visitJSDocUnionType(<ts.JSDocUnionType>val, parent)
      break;
    case ts.SyntaxKind.JSDocTupleType:
      this.visitJSDocTupleType(<ts.JSDocTupleType>val, parent)
      break;
    case ts.SyntaxKind.JSDocNullableType:
      this.visitJSDocNullableType(<ts.JSDocNullableType>val, parent)
      break;
    case ts.SyntaxKind.JSDocNonNullableType:
      this.visitJSDocNonNullableType(<ts.JSDocNonNullableType>val, parent)
      break;
    case ts.SyntaxKind.JSDocRecordType:
      this.visitJSDocRecordType(<ts.JSDocRecordType>val, parent)
      break;
    case ts.SyntaxKind.JSDocRecordMember:
      this.visitJSDocRecordMember(<ts.JSDocRecordMember>val, parent)
      break;
    case ts.SyntaxKind.JSDocTypeReference:
      this.visitJSDocTypeReference(<ts.JSDocTypeReference>val, parent)
      break;
    case ts.SyntaxKind.JSDocOptionalType:
      this.visitJSDocOptionalType(<ts.JSDocOptionalType>val, parent)
      break;
    case ts.SyntaxKind.JSDocFunctionType:
      this.visitJSDocFunctionType(<ts.JSDocFunctionType>val, parent)
      break;
    case ts.SyntaxKind.JSDocVariadicType:
      this.visitJSDocVariadicType(<ts.JSDocVariadicType>val, parent)
      break;
    case ts.SyntaxKind.JSDocConstructorType:
      this.visitJSDocConstructorType(<ts.JSDocConstructorType>val, parent)
      break;
    case ts.SyntaxKind.JSDocThisType:
      this.visitJSDocThisType(<ts.JSDocThisType>val, parent)
      break;
    case ts.SyntaxKind.JSDocComment:
      this.visitJSDoc(<ts.JSDoc>val, parent)
      break;
    case ts.SyntaxKind.JSDocTag:
      this.visitJSDocUnknownTag(<ts.JSDocUnknownTag>val, parent)
      break;
    case ts.SyntaxKind.JSDocAugmentsTag:
      this.visitJSDocAugmentsTag(<ts.JSDocAugmentsTag>val, parent)
      break;
    case ts.SyntaxKind.JSDocClassTag:
      this.visitJSDocClassTag(<ts.JSDocClassTag>val, parent)
      break;
    case ts.SyntaxKind.JSDocParameterTag:
      this.visitJSDocParameterTag(<ts.JSDocParameterTag>val, parent)
      break;
    case ts.SyntaxKind.JSDocReturnTag:
      this.visitJSDocReturnTag(<ts.JSDocReturnTag>val, parent)
      break;
    case ts.SyntaxKind.JSDocTypeTag:
      this.visitJSDocTypeTag(<ts.JSDocTypeTag>val, parent)
      break;
    case ts.SyntaxKind.JSDocTemplateTag:
      this.visitJSDocTemplateTag(<ts.JSDocTemplateTag>val, parent)
      break;
    case ts.SyntaxKind.JSDocTypeLiteral:
      this.visitJSDocTypeLiteral(<ts.JSDocTypeLiteral>val, parent)
      break;
    case ts.SyntaxKind.JSDocLiteralType:
      this.visitJSDocLiteralType(<ts.JSDocLiteralType>val, parent)
      break;
    case ts.SyntaxKind.NotEmittedStatement:
      this.visitNotEmittedStatement(<ts.NotEmittedStatement>val, parent)
      break;
    case ts.SyntaxKind.PartiallyEmittedExpression:
      this.visitPartiallyEmittedExpression(<ts.PartiallyEmittedExpression>val, parent)
      break;
    case ts.SyntaxKind.CommaListExpression:
      this.visitCommaListExpression(<ts.CommaListExpression>val, parent)
      break;
    case ts.SyntaxKind.FirstTypeNode:
      this.visitTypePredicateNode(<ts.TypePredicateNode>val, parent)
      break;
    case ts.SyntaxKind.LastTypeNode:
      this.visitLiteralTypeNode(<ts.LiteralTypeNode>val, parent)
      break;
    case ts.SyntaxKind.FirstLiteralToken:
      this.visitNumericLiteral(<ts.NumericLiteral>val, parent)
      break;
    case ts.SyntaxKind.LastLiteralToken:
      this.visitNoSubstitutionTemplateLiteral(<ts.NoSubstitutionTemplateLiteral>val, parent)
      break;
    case ts.SyntaxKind.FirstTemplateToken:
      this.visitNoSubstitutionTemplateLiteral(<ts.NoSubstitutionTemplateLiteral>val, parent)
      break;
    case ts.SyntaxKind.LastTemplateToken:
      this.visitTemplateTail(<ts.TemplateTail>val, parent)
      break;
    case ts.SyntaxKind.FirstNode:
      this.visitQualifiedName(<ts.QualifiedName>val, parent)
      break;
    case ts.SyntaxKind.FirstJSDocNode:
      this.visitJSDocTypeExpression(<ts.JSDocTypeExpression>val, parent)
      break;
    case ts.SyntaxKind.LastJSDocNode:
      this.visitJSDocLiteralType(<ts.JSDocLiteralType>val, parent)
      break;
    case ts.SyntaxKind.FirstJSDocTagNode:
      this.visitJSDocUnknownTag(<ts.JSDocUnknownTag>val, parent)
      break;
    case ts.SyntaxKind.LastJSDocTagNode:
      this.visitJSDocLiteralType(<ts.JSDocLiteralType>val, parent)
      break;
    }
  }

}

export default Visitor

